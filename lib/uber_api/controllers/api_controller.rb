# This file was automatically generated by APIMATIC v2.0 ( https://apimatic.io ).

module UberApi
  class APIController < BaseController
    @@instance = APIController.new
    # Singleton instance of the controller class
    def self.instance
      @@instance
    end

    # Get product details w.r.t id
    # @param [String] product_id Required parameter: Unique identifier representing a specific product for a given latitude & longitude. For example, uberX in San Francisco will have a different product_id than uberX in Los Angeles.
    # @return Product response from the API call
    def get_product_detail_by_id(product_id)

      # validate required parameters
      validate_parameters({
        'product_id' => product_id
      })

      # prepare query url
      _query_builder = Configuration.base_uri.dup
      _query_builder << '/v1/products/{product_id}'
      _query_builder = APIHelper.append_url_with_template_parameters _query_builder, {
        'product_id' => product_id
      }
      _query_url = APIHelper.clean_url _query_builder

      # prepare headers
      _headers = {
        'accept' => 'application/json'
      }

      # prepare and execute HttpRequest
      _request = @http_client.get _query_url, headers: _headers
      OAuth2.apply(_request)
      _context = execute_request(_request)

      # validate response against endpoint and global error codes
      if _context.response.status_code == 404
        return nil
      end
      validate_response(_context)

      # return appropriate response type
      decoded = APIHelper.json_deserialize(_context.response.raw_body)
      return Product.from_hash(decoded)
    end

    # The User Profile endpoint returns information about the Uber user that has authorized with the application.
    # @return UserProfile response from the API call
    def get_user_profile

      # prepare query url
      _query_builder = Configuration.base_uri.dup
      _query_builder << '/v1/me'
      _query_url = APIHelper.clean_url _query_builder

      # prepare headers
      _headers = {
        'accept' => 'application/json'
      }

      # prepare and execute HttpRequest
      _request = @http_client.get _query_url, headers: _headers
      OAuth2.apply(_request)
      _context = execute_request(_request)

      # validate response against endpoint and global error codes
      if _context.response.status_code == 404
        return nil
      elsif _context.response.status_code == 400
        raise APIException.new 'Malformed request.', _context
      elsif _context.response.status_code == 401
        raise APIException.new 'Unauthorized the request requires user authentication (not logged in).', _context
      elsif _context.response.status_code == 403
        raise APIException.new 'Forbidden. Also used for unauthorized requests such as improper OAuth 2.0 scopes or permissions issues.', _context
      elsif _context.response.status_code == 406
        raise APIException.new 'Unacceptable content type. Client sent an accepts header for a content type which does not exist on the server. Body includes a list of acceptable content types: ?Unacceptable content type. Request resource as: application/json, etc.', _context
      elsif _context.response.status_code == 422
        raise APIException.new 'Invalid request. The request body is parse-able however with invalid content.', _context
      elsif _context.response.status_code == 429
        raise APIException.new 'Too Many Requests. Rate limited.', _context
      elsif _context.response.status_code == 500
        raise APIException.new 'Internal Server Error.', _context
      end
      validate_response(_context)

      # return appropriate response type
      decoded = APIHelper.json_deserialize(_context.response.raw_body)
      return UserProfile.from_hash(decoded)
    end

    # The Products endpoint returns information about the Uber products offered at a given location. The response includes the display name and other details about each product, and lists the products in the proper display order.
    # @param [Float] latitude Required parameter: Latitude component of location.
    # @param [Float] longitude Required parameter: Longitude component of location.
    # @return ProductCollection response from the API call
    def get_products_types(latitude, 
                           longitude)

      # validate required parameters
      validate_parameters({
        'latitude' => latitude,
        'longitude' => longitude
      })

      # prepare query url
      _query_builder = Configuration.base_uri.dup
      _query_builder << '/v1/products'
      _query_builder = APIHelper.append_url_with_query_parameters _query_builder, {
        'latitude' => latitude,
        'longitude' => longitude
      }
      _query_url = APIHelper.clean_url _query_builder

      # prepare headers
      _headers = {
        'accept' => 'application/json'
      }

      # prepare and execute HttpRequest
      _request = @http_client.get _query_url, headers: _headers
      OAuth2.apply(_request)
      _context = execute_request(_request)

      # validate response against endpoint and global error codes
      if _context.response.status_code == 404
        return nil
      elsif _context.response.status_code == 400
        raise APIException.new 'Malformed request.', _context
      elsif _context.response.status_code == 401
        raise APIException.new 'Unauthorized the request requires user authentication (not logged in).', _context
      elsif _context.response.status_code == 403
        raise APIException.new 'Forbidden. Also used for unauthorized requests such as improper OAuth 2.0 scopes or permissions issues.', _context
      elsif _context.response.status_code == 406
        raise APIException.new 'Unacceptable content type. Client sent an accepts header for a content type which does not exist on the server. Body includes a list of acceptable content types: ?Unacceptable content type. Request resource as: application/json, etc.', _context
      elsif _context.response.status_code == 422
        raise APIException.new 'Invalid request. The request body is parse-able however with invalid content.', _context
      elsif _context.response.status_code == 429
        raise APIException.new 'Too Many Requests. Rate limited.', _context
      elsif _context.response.status_code == 500
        raise APIException.new 'Internal Server Error.', _context
      end
      validate_response(_context)

      # return appropriate response type
      decoded = APIHelper.json_deserialize(_context.response.raw_body)
      return ProductCollection.from_hash(decoded)
    end

    # Get the real time status of an ongoing trip that was created using the Ride Request endpoint.
    # @param [String] request_id Required parameter: Example: 
    # @return RequestDetailsCollections response from the API call
    def get_request_details(request_id)

      # validate required parameters
      validate_parameters({
        'request_id' => request_id
      })

      # prepare query url
      _query_builder = Configuration.base_uri.dup
      _query_builder << '/v1/requests/{request_id}'
      _query_builder = APIHelper.append_url_with_template_parameters _query_builder, {
        'request_id' => request_id
      }
      _query_url = APIHelper.clean_url _query_builder

      # prepare headers
      _headers = {
        'accept' => 'application/json'
      }

      # prepare and execute HttpRequest
      _request = @http_client.get _query_url, headers: _headers
      OAuth2.apply(_request)
      _context = execute_request(_request)

      # validate response against endpoint and global error codes
      if _context.response.status_code == 404
        return nil
      elsif _context.response.status_code == 400
        raise APIException.new 'Malformed request.', _context
      elsif _context.response.status_code == 401
        raise APIException.new 'Unauthorized the request requires user authentication (not logged in).', _context
      elsif _context.response.status_code == 403
        raise APIException.new 'Forbidden. Also used for unauthorized requests such as improper OAuth 2.0 scopes or permissions issues.', _context
      elsif _context.response.status_code == 406
        raise APIException.new 'Unacceptable content type. Client sent an accepts header for a content type which does not exist on the server. Body includes a list of acceptable content types, such as ?Unacceptable content type. Request resource as: application/json.', _context
      elsif _context.response.status_code == 409
        raise APIException.new 'A conflict needs to be resolved before the request can be made.', _context
      elsif _context.response.status_code == 422
        raise APIException.new 'Invalid request. The request body is parse-able however with invalid content or there are issues with a rider's user account.', _context
      elsif _context.response.status_code == 429
        raise APIException.new 'Too Many Requests. Rate limited.', _context
      elsif _context.response.status_code == 500
        raise APIException.new 'Internal Server Error', _context
      end
      validate_response(_context)

      # return appropriate response type
      decoded = APIHelper.json_deserialize(_context.response.raw_body)
      return RequestDetailsCollections.from_hash(decoded)
    end

    # The User Activity endpoint returns data about a user's lifetime activity with Uber. The response will include pickup locations and times, dropoff locations and times, the distance of past requests, and information about which products were requested.
    # @param [Integer] limit Required parameter: Number of items to return for pagging
    # @param [Integer] offset Required parameter: Page offset for pagging
    # @return UserActivity response from the API call
    def get_user_activity_v_1_1(limit, 
                                offset)

      # validate required parameters
      validate_parameters({
        'limit' => limit,
        'offset' => offset
      })

      # prepare query url
      _query_builder = Configuration.base_uri.dup
      _query_builder << '/v1.1/history'
      _query_builder = APIHelper.append_url_with_query_parameters _query_builder, {
        'limit' => limit,
        'offset' => offset
      }
      _query_url = APIHelper.clean_url _query_builder

      # prepare headers
      _headers = {
        'accept' => 'application/json'
      }

      # prepare and execute HttpRequest
      _request = @http_client.get _query_url, headers: _headers
      OAuth2.apply(_request)
      _context = execute_request(_request)

      # validate response against endpoint and global error codes
      if _context.response.status_code == 404
        return nil
      elsif _context.response.status_code == 400
        raise APIException.new 'Malformed request.', _context
      elsif _context.response.status_code == 401
        raise APIException.new 'Unauthorized the request requires user authentication (not logged in).', _context
      elsif _context.response.status_code == 403
        raise APIException.new 'Forbidden. Also used for unauthorized requests such as improper OAuth 2.0 scopes or permissions issues.', _context
      elsif _context.response.status_code == 406
        raise APIException.new 'Unacceptable content type. Client sent an accepts header for a content type which does not exist on the server. Body includes a list of acceptable content types: ?Unacceptable content type. Request resource as: application/json, etc.', _context
      elsif _context.response.status_code == 422
        raise APIException.new 'Invalid request. The request body is parse-able however with invalid content.', _context
      elsif _context.response.status_code == 429
        raise APIException.new 'Too Many Requests. Rate limited.', _context
      elsif _context.response.status_code == 500
        raise APIException.new 'Internal Server Error.', _context
      end
      validate_response(_context)

      # return appropriate response type
      decoded = APIHelper.json_deserialize(_context.response.raw_body)
      return UserActivity.from_hash(decoded)
    end

    # The Time Estimates endpoint returns ETAs for all products offered at a given location, with the responses expressed as integers in seconds. We recommend that this endpoint be called every minute to provide the most accurate, up-to-date ETAs.
    # @param [Float] start_latitude Required parameter: Latitude component of the start location
    # @param [Float] start_longitude Required parameter: Longitude component of the start location
    # @param [String] customer_uuid Optional parameter: The customer id interested in estimate
    # @param [String] product_id Optional parameter: Id of the requested product
    # @return TimeEstimateCollection response from the API call
    def get_time_estimates(start_latitude, 
                           start_longitude, 
                           customer_uuid = nil, 
                           product_id = nil)

      # validate required parameters
      validate_parameters({
        'start_latitude' => start_latitude,
        'start_longitude' => start_longitude
      })

      # prepare query url
      _query_builder = Configuration.base_uri.dup
      _query_builder << '/v1/estimates/time'
      _query_builder = APIHelper.append_url_with_query_parameters _query_builder, {
        'start_latitude' => start_latitude,
        'start_longitude' => start_longitude,
        'customer_uuid' => customer_uuid,
        'product_id' => product_id
      }
      _query_url = APIHelper.clean_url _query_builder

      # prepare headers
      _headers = {
        'accept' => 'application/json'
      }

      # prepare and execute HttpRequest
      _request = @http_client.get _query_url, headers: _headers
      OAuth2.apply(_request)
      _context = execute_request(_request)

      # validate response against endpoint and global error codes
      if _context.response.status_code == 404
        return nil
      elsif _context.response.status_code == 400
        raise APIException.new 'Malformed request.', _context
      elsif _context.response.status_code == 401
        raise APIException.new 'Unauthorized the request requires user authentication (not logged in).', _context
      elsif _context.response.status_code == 403
        raise APIException.new 'Forbidden. Also used for unauthorized requests such as improper OAuth 2.0 scopes or permissions issues.', _context
      elsif _context.response.status_code == 406
        raise APIException.new 'Unacceptable content type. Client sent an accepts header for a content type which does not exist on the server. Body includes a list of acceptable content types: ?Unacceptable content type. Request resource as: application/json, etc.', _context
      elsif _context.response.status_code == 422
        raise APIException.new 'Invalid request. The request body is parse-able however with invalid content.', _context
      elsif _context.response.status_code == 429
        raise APIException.new 'Too Many Requests. Rate limited.', _context
      elsif _context.response.status_code == 500
        raise APIException.new 'Internal Server Error.', _context
      end
      validate_response(_context)

      # return appropriate response type
      decoded = APIHelper.json_deserialize(_context.response.raw_body)
      return TimeEstimateCollection.from_hash(decoded)
    end

    # The Price Estimates endpoint returns an estimated price range for each product offered at a given location. The price estimate is provided as a formatted string with the full price range and the localized currency symbol.
    # @param [Float] end_latitude Required parameter: Latitude component of end location.
    # @param [Float] end_longitude Required parameter: Longitude component of end location.
    # @param [Float] start_latitude Required parameter: Latitude component of start location.
    # @param [Float] start_longitude Required parameter: Longitude component of start location.
    # @return PriceEstimateCollection response from the API call
    def get_price_estimates(end_latitude, 
                            end_longitude, 
                            start_latitude, 
                            start_longitude)

      # validate required parameters
      validate_parameters({
        'end_latitude' => end_latitude,
        'end_longitude' => end_longitude,
        'start_latitude' => start_latitude,
        'start_longitude' => start_longitude
      })

      # prepare query url
      _query_builder = Configuration.base_uri.dup
      _query_builder << '/v1/estimates/price'
      _query_builder = APIHelper.append_url_with_query_parameters _query_builder, {
        'end_latitude' => end_latitude,
        'end_longitude' => end_longitude,
        'start_latitude' => start_latitude,
        'start_longitude' => start_longitude
      }
      _query_url = APIHelper.clean_url _query_builder

      # prepare headers
      _headers = {
        'accept' => 'application/json'
      }

      # prepare and execute HttpRequest
      _request = @http_client.get _query_url, headers: _headers
      OAuth2.apply(_request)
      _context = execute_request(_request)

      # validate response against endpoint and global error codes
      if _context.response.status_code == 404
        return nil
      elsif _context.response.status_code == 400
        raise APIException.new 'Malformed request.', _context
      elsif _context.response.status_code == 401
        raise APIException.new 'Unauthorized the request requires user authentication (not logged in).', _context
      elsif _context.response.status_code == 403
        raise APIException.new 'Forbidden. Also used for unauthorized requests such as improper OAuth 2.0 scopes or permissions issues.', _context
      elsif _context.response.status_code == 406
        raise APIException.new 'Unacceptable content type. Client sent an accepts header for a content type which does not exist on the server. Body includes a list of acceptable content types: ?Unacceptable content type. Request resource as: application/json, etc.', _context
      elsif _context.response.status_code == 422
        raise APIException.new 'Invalid request. The request body is parse-able however with invalid content.', _context
      elsif _context.response.status_code == 429
        raise APIException.new 'Too Many Requests. Rate limited.', _context
      elsif _context.response.status_code == 500
        raise APIException.new 'Internal Server Error.', _context
      end
      validate_response(_context)

      # return appropriate response type
      decoded = APIHelper.json_deserialize(_context.response.raw_body)
      return PriceEstimateCollection.from_hash(decoded)
    end

    # Get a map with a visual representation of a Request.
    # @param [String] request_id Required parameter: Unique identifier representing a Request.
    # @return RequestMapResponse response from the API call
    def get_request_map(request_id)

      # validate required parameters
      validate_parameters({
        'request_id' => request_id
      })

      # prepare query url
      _query_builder = Configuration.base_uri.dup
      _query_builder << '/v1/requests/{request_id}/map'
      _query_builder = APIHelper.append_url_with_template_parameters _query_builder, {
        'request_id' => request_id
      }
      _query_url = APIHelper.clean_url _query_builder

      # prepare headers
      _headers = {
        'accept' => 'application/json'
      }

      # prepare and execute HttpRequest
      _request = @http_client.get _query_url, headers: _headers
      OAuth2.apply(_request)
      _context = execute_request(_request)

      # validate response against endpoint and global error codes
      if _context.response.status_code == 404
        return nil
      elsif _context.response.status_code == 400
        raise APIException.new 'Malformed request.', _context
      elsif _context.response.status_code == 401
        raise APIException.new 'Unauthorized the request requires user authentication (not logged in).', _context
      elsif _context.response.status_code == 403
        raise APIException.new 'Forbidden. Also used for unauthorized requests such as improper OAuth 2.0 scopes or permissions issues', _context
      elsif _context.response.status_code == 406
        raise APIException.new 'Unacceptable content type. Client sent an accepts header for a content type which does not exist on the server. Body includes a list of acceptable content types, such as ?Unacceptable content type. Request resource as: application/json.', _context
      elsif _context.response.status_code == 409
        raise APIException.new 'A conflict needs to be resolved before the request can be made.', _context
      elsif _context.response.status_code == 422
        raise APIException.new 'Invalid request. The request body is parse-able however with invalid content or there are issues with a rider's user account.', _context
      elsif _context.response.status_code == 429
        raise APIException.new 'Too Many Requests. Rate limited.', _context
      elsif _context.response.status_code == 500
        raise APIException.new 'Internal Server Error.', _context
      end
      validate_response(_context)

      # return appropriate response type
      decoded = APIHelper.json_deserialize(_context.response.raw_body)
      return RequestMapResponse.from_hash(decoded)
    end

    # Cancel an ongoing Request on behalf of a rider.
    # @param [String] request_id Required parameter: Unique identifier representing a Request.
    # @return void response from the API call
    def delete_request_cancel(request_id)

      # validate required parameters
      validate_parameters({
        'request_id' => request_id
      })

      # prepare query url
      _query_builder = Configuration.base_uri.dup
      _query_builder << '/v1/requests/{request_id}'
      _query_builder = APIHelper.append_url_with_template_parameters _query_builder, {
        'request_id' => request_id
      }
      _query_url = APIHelper.clean_url _query_builder

      # prepare and execute HttpRequest
      _request = @http_client.delete _query_url
      OAuth2.apply(_request)
      _context = execute_request(_request)

      # validate response against endpoint and global error codes
      if _context.response.status_code == 400
        raise APIException.new 'Malformed request.', _context
      elsif _context.response.status_code == 401
        raise APIException.new 'Unauthorized the request requires user authentication (not logged in).', _context
      elsif _context.response.status_code == 403
        raise APIException.new 'Forbidden. Also used for unauthorized requests such as improper OAuth 2.0 scopes or permissions issues.', _context
      elsif _context.response.status_code == 406
        raise APIException.new 'Unacceptable content type. Client sent an accepts header for a content type which does not exist on the server. Body includes a list of acceptable content types, such as ?Unacceptable content type. Request resource as: application/json.', _context
      elsif _context.response.status_code == 409
        raise APIException.new 'A conflict needs to be resolved before the request can be made', _context
      elsif _context.response.status_code == 422
        raise APIException.new 'Invalid request. The request body is parse-able however with invalid content or there are issues with a rider's user account.', _context
      elsif _context.response.status_code == 429
        raise APIException.new 'Too Many Requests. Rate limited.', _context
      elsif _context.response.status_code == 500
        raise APIException.new 'Internal Server Error', _context
      end
      validate_response(_context)
    end

    # The Request endpoint allows a ride to be requested on behalf of an Uber user given their desired product, start, and end locations. Please review the Sandbox documentation on how to develop and test against these endpoints without making real-world Requests and being charged.
    # @param [RequestBody] body Required parameter: Example: 
    # @return Request response from the API call
    def create_request(body)

      # validate required parameters
      validate_parameters({
        'body' => body
      })

      # prepare query url
      _query_builder = Configuration.base_uri.dup
      _query_builder << '/v1/requests'
      _query_url = APIHelper.clean_url _query_builder

      # prepare headers
      _headers = {
        'accept' => 'application/json',
        'content-type' => 'application/json; charset=utf-8'
      }

      # prepare and execute HttpRequest
      _request = @http_client.post _query_url, headers: _headers, parameters: body.to_json
      OAuth2.apply(_request)
      _context = execute_request(_request)

      # validate response against endpoint and global error codes
      if _context.response.status_code == 404
        return nil
      elsif _context.response.status_code == 400
        raise APIException.new 'Malformed request', _context
      elsif _context.response.status_code == 401
        raise APIException.new 'Unauthorized the request requires user authentication (not logged in).', _context
      elsif _context.response.status_code == 403
        raise APIException.new 'Forbidden. Also used for unauthorized requests such as improper OAuth 2.0 scopes or permissions issues.', _context
      elsif _context.response.status_code == 406
        raise APIException.new 'Unacceptable content type. Client sent an accepts header for a content type which does not exist on the server. Body includes a list of acceptable content types, such as ?Unacceptable content type. Request resource as: application/json', _context
      elsif _context.response.status_code == 409
        raise APIException.new 'A conflict needs to be resolved before the request can be made.', _context
      elsif _context.response.status_code == 422
        raise APIException.new 'Invalid request. The request body is parse-able however with invalid content or there are issues with a rider's user account.', _context
      elsif _context.response.status_code == 429
        raise APIException.new 'Too Many Requests. Rate limited.', _context
      elsif _context.response.status_code == 500
        raise APIException.new 'Internal Server Error.', _context
      end
      validate_response(_context)

      # return appropriate response type
      decoded = APIHelper.json_deserialize(_context.response.raw_body)
      return Request.from_hash(decoded)
    end

    # The Promotions endpoint returns information about the promotion that will be available to a new user based on their activity's location. These promotions do not apply for existing users.
    # @param [Float] end_latitude Required parameter: Latitude component of end location.
    # @param [Float] end_longitude Required parameter: Longitude component of end location.
    # @param [Float] start_latitude Required parameter: Latitude component of start location.
    # @param [Float] start_longitude Required parameter: Longitude component of start location
    # @return PromotionsResponse response from the API call
    def get_promotions(end_latitude, 
                       end_longitude, 
                       start_latitude, 
                       start_longitude)

      # validate required parameters
      validate_parameters({
        'end_latitude' => end_latitude,
        'end_longitude' => end_longitude,
        'start_latitude' => start_latitude,
        'start_longitude' => start_longitude
      })

      # prepare query url
      _query_builder = Configuration.base_uri.dup
      _query_builder << '/v1/promotions'
      _query_builder = APIHelper.append_url_with_query_parameters _query_builder, {
        'end_latitude' => end_latitude,
        'end_longitude' => end_longitude,
        'start_latitude' => start_latitude,
        'start_longitude' => start_longitude
      }
      _query_url = APIHelper.clean_url _query_builder

      # prepare headers
      _headers = {
        'accept' => 'application/json'
      }

      # prepare and execute HttpRequest
      _request = @http_client.get _query_url, headers: _headers
      OAuth2.apply(_request)
      _context = execute_request(_request)

      # validate response against endpoint and global error codes
      if _context.response.status_code == 404
        return nil
      elsif _context.response.status_code == 400
        raise APIException.new 'Malformed request.', _context
      elsif _context.response.status_code == 401
        raise APIException.new 'Unauthorized the request requires user authentication (not logged in).', _context
      elsif _context.response.status_code == 403
        raise APIException.new 'Forbidden. Also used for unauthorized requests such as improper OAuth 2.0 scopes or permissions issues.', _context
      elsif _context.response.status_code == 406
        raise APIException.new 'Unacceptable content type. Client sent an accepts header for a content type which does not exist on the server. Body includes a list of acceptable content types, such as ?Unacceptable content type. Request resource as: application/json.', _context
      elsif _context.response.status_code == 409
        raise APIException.new 'A conflict needs to be resolved before the request can be made.', _context
      elsif _context.response.status_code == 422
        raise APIException.new 'Invalid request. The request body is parse-able however with invalid content or there are issues with a rider's user account.', _context
      elsif _context.response.status_code == 429
        raise APIException.new 'Too Many Requests. Rate limited', _context
      elsif _context.response.status_code == 500
        raise APIException.new 'Internal Server Error.', _context
      end
      validate_response(_context)

      # return appropriate response type
      decoded = APIHelper.json_deserialize(_context.response.raw_body)
      return PromotionsResponse.from_hash(decoded)
    end
  end
end
